Codes and commands for Chapter 9
================================

-- Perform a full database export

expdp system/oracle full=y transportable=always version=12.0 dumpfile=expfull.dat directory=DUMP_DIR logfile=expfull.log

-- Following example shows how to use DBMS_FILE_TRANSFER package to change the endianness of datafiles from source system to target system using either PUT_FILE or GET_FILE procedure

BEGIN
  DBMS_FILE_TRANSFER.PUT_FILE(
		source_directory_object      => ‘SRC_DUMP_DIR’, 
		source_file_name             => ‘data.dbf’,     
		destination_directory_object => ‘DEST_DUMP_DIR’,
		destination_file_name 	    => ‘data.dbf’,     
		destination_database 	    => ‘targetdb’);    
END;
/

-- Perform a full database transportable import

impdp system/oracle@pdb4 dumpfile=expfull.dat directory=DUMP_DIR transport_datafiles='/u01/app/oracle/oradata/orcl/pdb4/datafiles/users-01.dbf','/u01/app/oracle/oradata/orcl/pdb4/datafiles/low_cost_storage-01.dbf' logfile=import.log


-- If you want to perform a network_link transport, you can do so using the following command

impdp system/oracle@pdb4 network_link=deo transport_datafiles='/u01/app/oracle/oradata/orcl/pdb4/datafiles/users-01.dbf','/u01/app/oracle/oradata/orcl/pdb4/datafiles/low_cost_storage-01.dbf' logfile=import.log

-- Disable archive logging for tables as well as indexes

impdp system/oracle@pdb4 dumpfile=expfull.dat directory=DUMP_DIR TRANSFORM=DISABLE_ARCHIVE_LOGGING:Y …

-- Disable archive logging for only indexes

impdp system/oracle@pdb4 dumpfile=expfull.dat directory=DUMP_DIR TRANSFORM=DISABLE_ARCHIVE_LOGGING:Y:INDEX

-- Disable archive logging for only tables

impdp system/oracle@pdb4 dumpfile=expfull.dat directory=DUMP_DIR TRANSFORM=DISABLE_ARCHIVE_LOGGING:Y:TABLE TRANSFORM=DISABLE_ARCHIVE_LOGGING:N:INDEX 

-- Exporting views as a table --
--------------------------------

expdp system/oracle directory=DUMP_DIR dumpfile=exp.dat view_as_tables=sales_view tables=sales,sales_items

-- In the import command we imported this view as table and renamed the table as SALES_SUMMARY using the REMAP_TABLE parameter, as shown in the following code

impdp system/oracle directory=DUMP_DIR dumpfile=exp.dat view_as_tables=sales_view remap_table=sales_view:sales_summary tables=sales,sales_items

-- Here is another example

impdp system/oracle directory=DUMP_DIR dumpfile=exp.dat view_as_tables=sales_view remap_table=sales_view:sales_items tables=sales table_exists_action=append

-- Compressing data during import

impdp system/oracle directory=DUMP_DIR dumpfile=exp.dat tables=sales TRANSFORM=TABLE_COMPRESSION_CLAUSE:"ROW STORE COMPRESS ADVANCED"


-- SQL* Loader express mode --
------------------------------

-- following code shows running an SQL Loader in express mode (only username and table_name is provided)

sqlldr oe/oracle table=order_items_copy

-- Support for loading of identity columns --
---------------------------------------------

-- NUMBER GENERATED ALWAYS AS IDENTITY

create table t1 (
col1 number generated always as identity,
col2 varchar2(10));

insert into T1 (col2) values ('A');

select * from T1;

insert into T1 values (null, 'B');

insert into T1 values (2,'B');

-- NUMBER GENERATED BY DEFAULT AS IDENTITY

create table t1 (
col1 number generated by default as identity,
col2 varchar2(10));

insert into T1 (col2) values ('A');

select * from T1;

insert into T1 values (null, 'B');

insert into T1 values (2,'B');

select * from T1;

insert into T1 (col2) values ('C');

select * from T1;


-- NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY


create table T2(
col1 number generated by default on null as identity,
col2 varchar2(10));

insert into T2 (col2) values ('A');

select * from T2;

insert into T2 values (null, 'B');

insert into T2 values (3, 'C');

select * from T2;

insert into T2 values (null, 'D');

select * from T2;

-- Online partition operations --
---------------------------------


-- Moving the partition to a low cost storage ONLINE

alter table sales move partition SALES_1996 tablespace low_cost_storage update indexes online;

select index_name, status from dba_indexes where index_name = 'I_SALES_PROD_CUST_ID';

-- Compressing the partition – row level basic level

alter table sales move partition SALES_1996 row store compress basic update indexes online;

-- Compressing the partition – row level advanced level

alter table sales move partition SALES_1996 row store compress advanced update indexes online;

-- Interval reference partitioning --
-------------------------------------

-- create an interval partition parent table and reference partition child table

create table parent(
col1 number primary key,
col2 number,      
col3 varchar2(10))
partition by range(col2) interval(100)
(partition P1 values less than (100));


create table child(
col1 number primary key,
col2 number not null,
col3 varchar2(10),
constraint child_fk foreign key(col2) references parent(col1) on delete cascade)
partition by reference(child_fk);

-- check the partitions, add data in the parent table, and check the partitions again

select table_name, partition_name, high_value, interval from user_tab_partitions where table_name in ('PARENT','CHILD') order by 1, 2;

insert into parent values (10,10,'A');

insert into parent values (110,110,'B');

insert into parent values (210,210,'C');

select table_name, partition_name, high_value, interval from user_tab_partitions where table_name in ('PARENT','CHILD') order by 1, 2;

-- add some records in the child table too, and see if partitions are created automatically and if the name of the partitions are inherited from the parent table

insert into child values (1,110,'A');

insert into child values (2,210,'B');

commit;

select table_name, partition_name, high_value, interval from user_tab_partitions where table_name in ('PARENT','CHILD') order by 1, 2;

-- try splitting the interval partitions, as shown in the following code

alter table parent split partition for (150) at (150) into (partition P2, partition P3);

-- can see the corresponding partition split in the child table and that the partition names are inherited from the parent table

select table_name, partition_name, high_value, interval from user_tab_partitions where table_name in ('PARENT','CHILD') order by 1, 2;

-- CASCADE option for truncate partition --
-------------------------------------------

-- we created a child table with a referential integrity constraint and added the ON DELETE CASCADE clause. If you don't add this clause, then the cascade clause will not work on the parent table and you will get the error

alter table parent truncate partition SYS_P811 cascade;

-- If there are multiple referential constraints between a parent and a child table, at least one of those constraints needs to have ON DELETE CASCADE enabled for the TRUNCATE TABLE CASCADE operation to succeed.


alter table parent truncate partition SYS_P811 cascade;

select * from child;

-- Multi-partition maintenance operations --
---------------------------------------------

-- Adding multiple partitions

alter table sales add
partition sales_q1_2004 values less than (to_date('01-APR-2004','DD-MON-YYYY')),
partition sales_q2_2004 values less than (to_date('01-JUL-2004','DD-MON-YYYY')),
partition sales_q3_2004 values less than (to_date('01-OCT-2004','DD-MON-YYYY')),
partition sales_q4_2004 values less than (to_date('01-JAN-2005','DD-MON-YYYY'));

-- Truncating multiple partitions

alter table sales truncate partition sales_q1_2004, sales_q2_2004, sales_q3_2004, sales_q4_2004;

-- Merging multiple partitions

alter table sales merge partitions sales_q1_2004, sales_q2_2004, sales_q3_2004, sales_q4_2004 into partition sales_2004;

alter table sales merge partitions sales_q1_2004 to sales_q4_2004 into partition sales_2004;

-- Splitting multiple partitions

--- Splitting the range partition

alter table sales split partition sales_2000 into (
partition sales_q1_2000 values less than (to_date('01-APR-2000','DD-MON-YYYY')),
partition sales_q2_2000 values less than (to_date('01-JUL-2000','DD-MON-YYYY')),
partition sales_q3_2000 values less than (to_date('01-OCT-2000','DD-MON-YYYY')),
partition sales_q4_2000);

--- You can also see that data got split automatically into new partitions

select count(1) from sales partition (sales_q1_2000);

select count(1) from sales partition (sales_q2_2000);

--- Splitting the list partition

alter table list_part split partition INDIAN into(
partition north_indian values ('DELHI','CHANDIGARH'),
partition south_indian values ('TAMILNAIDU','KERALA'),
partition east_indian values ('ASSAM','MEGHALAYA'),
partition west_indian values ('MAHARASHTRA','GOA'));


--- Splitting the MAXVALUE partition

alter table sales split partition pmax into (
partition sales_q1_2004 values less than (to_date('01-APR-2004','DD-MON-YYYY')),
partition sales_q2_2004 values less than (to_date('01-JUL-2004','DD-MON-YYYY')),
partition sales_q3_2004 values less than (to_date('01-OCT-2004','DD-MON-YYYY')),
partition sales_q4_2004 values less than (to_date('01-JAN-2005','DD-MON-YYYY')),
partition pmax);

-- Dropping multiple partitions

alter table sales drop partition sales_q1_2004, sales_q2_2004, sales_q3_2004, sales_q4_2004;

-- Specifying default indexing property for table/partitions --
---------------------------------------------------------------

-- following example shows the defining indexing property for tables and partitions

create table T1 (
col1    number,
col2    date,
col3    varchar2(10))
indexing off
partition by range(col2)(
partition p1 values less than (to_date('01-JAN-2001','DD-MON-YYYY')),
partition p2 values less than (to_date('01-JAN-2002','DD-MON-YYYY')) indexing off,
partition p3 values less than (to_date('01-JAN-2003','DD-MON-YYYY')) indexing on,
partition p4 values less than (to_date('01-JAN-2004','DD-MON-YYYY')) indexing on);

-- Creating a partial local and global indexes

create index I_T1_COL1 on T1(col1) global indexing partial;

-- try to create a local index using the partition key COL2

create index I_T1_COL1_COL2 on T1(col2, col1) local indexing partial;

-- We can check this using the DBA_IND_PARTITIONS view, as shown in the following code

select index_name, partition_name, STATUS from dba_ind_partitions where index_name = 'I_T1_COL1_COL2';

-- try to create a FULL local index, as shown in the following code

drop index I_T1_COL1_COL2;

create index I_T1_COL1_COL2 on T1(col2, col1) local indexing full;

select index_name, partition_name, STATUS from dba_ind_partitions where index_name = 'I_T1_COL1_COL2';

alter table sales modify partition SALES_Q4_2003 indexing off;

-- Effect of partial indexes on SQL plans --
--------------------------------------------

-- We can see from the following code that partitions corresponding to year 2000 are USABLE, whereas partitions corresponding to 2001 are UNUSABLE

select index_name, partition_name, STATUS from dba_ind_partitions where index_name = 'T_TIME_ID' and (partition_name like '%2001' or partition_name like '%2000') order by 3; 

-- The row limiting clause --
-----------------------------

-- If we have a CUSTOMERS table and I want to check the top 10 customers that have the lowest income level, I can write the following query in previous versions of Oracle

select * from (select CUST_ID, CUST_CITY, CUST_INCOME_LEVEL from customers order by CUST_INCOME_LEVEL) where rownum <= 10;

-- following query produces same output as the previous query

select CUST_ID, CUST_CITY, CUST_INCOME_LEVEL from customers order by CUST_INCOME_LEVEL fetch first 10 rows only;

-- If you want to get the next 10 customers that have the lowest income level, you can use the OFFSET keyword and offset the result by 10. So Oracle will exclude the first 10 records and provide the output from the 11th to 20th record, as shown in the following code

select CUST_ID, CUST_CITY, CUST_INCOME_LEVEL from customers order by CUST_INCOME_LEVEL offset 10 rows fetch next 10 rows only;

-- We had 16 customers having this income level. If we use the 10 ROWS ONLY clause, then it will only display 10 rows:

select CUST_ID, CUST_CITY, CUST_INCOME_LEVEL from customers order by CUST_INCOME_LEVEL fetch first 10 rows with ties;

-- Extended datatypes --
------------------------

-- following are the steps to enable extended data types

shutdown immediate
startup upgrade
alter system set MAX_STRING_SIZE = 'EXTENDED';
sqlplus "as sysdba" @$ORACLE_HOME/rdbms/admin/utl32k.sql 
shut immediate
startup

-- The following are the examples for using extended data type

create table T1 (col1 number, col2 varchar2(32767));

alter table T1 add (col2 varchar2(32767));

alter table T1 modify (col2 varchar2(32767));
